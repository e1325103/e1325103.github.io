<!DOCTYPE html>
<style type="text/css">
    html, body {
        margin: 0;
        background-color: white;
        color: white;
    }
</style>
<meta charset="utf-8" />

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="three.min.js">    /* 3D WebGL library */</script>
<script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 fUV;

    void main() {
    fUV = uv;
    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
    }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    uniform sampler2D map;

    varying vec2 fUV;

    void main() {
    float d = texture2D(map, fUV).x;
    d = (d - 5.0) / 20.0;
    vec3 color;
    if (d < 0.5) {
    d = d / 0.5;
    d = floor(10.0 * d + 0.5) / 10.0;
    color = d * vec3(1.0, 1.0, 1.0) + (1.0 - d) * vec3(0.0, 0.0, 1.0);
    } else {
    d = (d - 0.5) / 0.5;
    d = 1.0 - d;
    d = floor(10.0 * d + 0.5) / 10.0;
    color = d * vec3(1.0, 1.0, 1.0) + (1.0 - d) * vec3(1.0, 0.0, 0.0);
    }
    gl_FragColor = vec4(color, 1.0);
    }
</script>
<script language="javascript" type="text/javascript">

    // NOTE ON JAVASCRIPT METHOD CHAINING (CASCADING)
    // each method must return an object that provides the next method in the chain.
    //
    // examples:
    // truck.turnLeft().turnRight().goReallyFast(); // here all methods return same object via this
    // d3.select("body")       // here we call select method of d3 object which returns a DOM object
    //   .append("svg")        // call append method of body object which returns another DOM object
    //   .attr("width", 10)    // call attr method of svg object which returns itself via this
    //   .attr("height", 10);  // call attr method of same svg object again

    // NOTE DEBUGGING
    // use browser console for debugging!

    // 2D draw area, with margin for axis labels
    var margin = { top: 20, right: 20, bottom: 60, left: 60 },
        width = 500 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

    // initial value ranges for KDE
    // changed via panning and zooming
    var minX = -100;
    var maxX = 500;
    var minY = -100;
    var maxY = 600;

    var o_minX = -100;
    var o_maxX = 500;
    var o_minY = -100;
    var o_maxY = 600;

    // related to threejs
    var dataTexture;
    var material;
    var scene, camera, renderer;
    var geometry, mesh;
    var TFUniforms;
    var texData;

    var drawContextInitialized = false;
    var redraw = false;
    var mouseDown = false;

    function init() {

        // message contains KDE result image
        // then 4 byte specifying resolution
        // then 4 byte specifying the bin of maximum probability
        // note: littleEndian = true, i.e. stored sequentially from least significant
        // to most significant bit, e.g. number 123 stored as 321
        //var msgByteLength = evt.data.byteLength;
        //console.log('Image received.')
        //if (!drawContextInitialized)
        //    texData = new Float32Array(evt.data.slice(0, msgByteLength - 8));
        //else
        //    texData.set(new Float32Array(evt.data.slice(0, msgByteLength - 8)));
        //var dataview = new DataView(evt.data); // to read data from ArrayBuffer at any offset
        //var resolution = dataview.getInt32(msgByteLength - 8, true);
        //var maxIntensity = dataview.getInt32(msgByteLength - 4, true);

        //if (isNaN(maxIntensity) || (maxIntensity <= 0.0)) {
        //    maxIntensity = 1.0;
        //}

        //console.log("message length " + msgByteLength);
        //console.log("kde result data image resolution " + dataview.getInt32(msgByteLength - 8, true));
        //console.log("max intensity " + dataview.getInt32(msgByteLength - 4, true));

        // linear mapping of X random variable points of interest to draw area x axis
        var x = d3.scale.linear()
            .domain([minX, maxX])
            .range([0, width]);

        // linear mapping of Y random variable points of interest to draw area y axis
        var y = d3.scale.linear()
            .domain([minY, maxY])
            .range([height, 0]);

        // svg container for axes
        d3.select("svg").remove(); // clear existing svg container
        var svg = d3.select("body") // return DOM object (related to html element) body
            .append("svg") // in body object create new svg object and return it
            .attr("width", width + margin.left + margin.right) // set svg attr and return itself
            .attr("height", height + margin.top + margin.bottom)
            .append("g") // in svg object create group of svg shapes and return it
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")"); // etc.

        // d3 axes
        var xAxis = d3.svg.axis()
            .scale(x) // scale axis to range x
            .orient("bottom");

        var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left");

        // draw x axis
        // note on "call" function:
        // below xAxis is a function returned by axis().
        // <whatever>.call(xAxis) is same as xAxis(<whatever>),
        // i.e. run xAxis() function on <whatever>, here on the svg group g object.
        svg.append("g") // group of svg shapes
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .attr("fill", "#888")
            .call(xAxis)
            .append("text")
            .attr("class", "label")
            .attr("x", width)
            .attr("y", 42)
            .style("text-anchor", "end")
            .text("departure delay (mins)");

        // draw y axis
        svg.append("g")
            .attr("class", "y axis")
            .attr("fill", "#888")
            .call(yAxis)
            .append("text")
            .attr("class", "label")
            .attr("transform", "rotate(-90)")
            .attr("y", -60)
            .attr("dy", ".71em")
            .style("text-anchor", "end")
            .text("arrival delay (mins)");

        //var texSize = texData.length;
        //var texWidth = Math.sqrt(texSize);

        if (!drawContextInitialized || redraw) {
            // kde histogram data texture
            //dataTexture = new THREE.DataTexture(texData, texWidth, texWidth, THREE.LuminanceFormat, THREE.FloatType);
            //dataTexture.wrapS = THREE.ClampToEdgeWrapping;
            //dataTexture.wrapT = THREE.ClampToEdgeWrapping;
            //dataTexture.magFilter = THREE.LinearFilter;
            //dataTexture.minFilter = THREE.LinearFilter;
            //dataTexture.repeat.set(1, 1);
            //dataTexture.needsUpdate = true;

            // quad geometry
            geometry = new THREE.PlaneGeometry(width, height, 1, 1);

            // basic material with histogram data texture
            // TODO
            // material = new THREE.MeshBasicMaterial( {wireframe: false, map: dataTexture } );

            material = new THREE.ShaderMaterial({
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent
            });

            d3.csv("2016.csv", function (error, data) {
                var textData = [];

                for (var i = 0; i < (959 * 37); i++) {
                    textData.push(+data[i].V);
                }

                //textData = [];
                //textData.push(0.0);
                //textData.push(0.25);
                //textData.push(0.5);
                //textData.push(0.75);

                dataTexture = new THREE.DataTexture(new Float32Array(textData), 959, 37, THREE.LuminanceFormat, THREE.FloatType);
                dataTexture.wrapS = THREE.ClampToEdgeWrapping;
                dataTexture.wrapT = THREE.ClampToEdgeWrapping;
                dataTexture.magFilter = THREE.LinearFilter;
                dataTexture.minFilter = THREE.LinearFilter;
                dataTexture.repeat.set(1, 1);
                dataTexture.needsUpdate = true;

                uniform = {
                    map: {
                        value: dataTexture
                    }
                };

                material.uniforms = uniform;
                material.needsUpdate = true;
                mesh.needsUpdate = true;
                renderer.render(scene, camera);
                console.log("Load Complete");
            });

            //var material = new THREE.MeshBasicMaterial({
            //    color: new THREE.Color(0x00ffff)
            //});

            // mesh
            mesh = new THREE.Mesh(geometry, material);

            // scene
            scene = new THREE.Scene();
            scene.add(mesh);

            // ortho camera
            // clipping plane distances: left, right, top, bottom, near, far
            camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 1, 1000);
            camera.position.z = 1000;

            // renderer
            if (!drawContextInitialized) {
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(width, height);

                // renderer placement
                renderer.domElement.style.position = "absolute";
                renderer.domElement.style.top = (margin.top) + "px";
                renderer.domElement.style.left = (margin.left) + "px";
                renderer.domElement.style.zIndex = "1";

                // append renderer to DOM
                document.body.appendChild(renderer.domElement);
            }

            redraw = false;

            drawContextInitialized = true;

        }

        //dataTexture.needsUpdate = true;

        // render once
        // renderer.render(scene, camera);

    }

    // note: bool parameter indicates whether event should propagate from outermost element inward instead of the default from innermost out.
    window.addEventListener("load", init, false);
    // TODO add listeners to create interaction, e.g. mousemove, wheel etc.

</script>
